{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warning This documentation is a work in process, and is far from complete. Formulaic is a high-performance implementation of Wilkinson formulas for Python, which are very useful for transforming dataframes into a form suitable for ingestion into various modelling frameworks (especially linear regression). Source Code : https://github.com/matthewwardrop/formulaic Issue tracker : https://github.com/matthewwardrop/formulaic/issues Warning While this project is now fully functional, the API is still subject to change between major versions ( 0.<major>.<minor> ) as we continue to improve things. If you are going to depend on it in another project, it is advisable to pin formulaic to within a major version, for example: formulaic>=0.1.0,<0.2 . It provides: high-performance dataframe to model-matrix conversions. support for reusing the encoding choices made during conversion of one data-set on other datasets. extensible formula parsing. extensible data input/output plugins, with implementations for: input: pandas.DataFrame pyarrow.Table output: pandas.DataFrame numpy.ndarray scipy.sparse.CSCMatrix support for symbolic differentiation of formulas (and hence model matrices). with more to come! For some examples of what Formulaic provides, and how to use it, please refer to the Basic Usage and Advanced Usage guides.","title":"Introduction"},{"location":"changelog/","text":"For the latest changes, please refer to the git log: https://github.com/matthewwardrop/formulaic/commits/master. 0.2.1 (22 January 2021) This is a minor patch release that brings in some valuable improvements. Keep track of the pandas dataframe index if outputting a pandas DataFrame . Fix using functions in formulae that are nested within a module or class. Avoid crashing when an attempt is made to generate an empty model matrix. Enriched setup.py with long description for a better experience on PyPI. 0.2.0 (21 January 2021) This is major release that brings in a large number of improvements, with a huge number of commits. Some API breakage from the experimental 0.1.x series is likely in various edge-cases. Highlights include: Enriched formula parser to support quoting, and evaluation of formulas involving fields with invalid Python names. Added commonly used stateful transformations (identity, center, scale, bs) Improved the helpfulness of error messages reported by the formula parser. Added support for basic calculus on formulas (useful when taking the gradient of linear models). Made it easier to extend Formulaic with additional materializers. Many internal improvements to code quality and reliability, including 100% test coverage. Added benchmarks for Formulaic against R and patsy. Added documentation. Miscellaneous other bugfixes and cleanups. 0.1.2 (6 November 2019) Performance improvements around the encoding of categorical features. Matthew Wardrop (1): Improve the performance of encoding operations. 0.1.1 (31 October 2019) No code changes here, just a verification that GitHub CI integration was working. Matthew Wardrop (1): Update Github workflow triggers. 0.1.0 (31 October 2019) This release added support for keeping track of encoding choices during model matrix generation, so that they can be reused on similarly structured data. It also added comprehensive unit testing and CI integration using GitHub actions. Matthew Wardrop (5): Add support for stateful transforms (including encoding). Fix tokenizing of nested Python function calls. Add support for nested transforms that return multiple columns, as well as passing through of materializer config through to transforms. Add comprehensive unit testing along with several small miscellaneous bug fixes and improvements. Add GitHub actions configuration. 0.0.1 (1 September 2019) Initial open sourcing of formulaic . Matthew Wardrop (1): Initial (mostly) working implementation of Wilkinson formulas.","title":"Changelog"},{"location":"changelog/#021-22-january-2021","text":"This is a minor patch release that brings in some valuable improvements. Keep track of the pandas dataframe index if outputting a pandas DataFrame . Fix using functions in formulae that are nested within a module or class. Avoid crashing when an attempt is made to generate an empty model matrix. Enriched setup.py with long description for a better experience on PyPI.","title":"0.2.1 (22 January 2021)"},{"location":"changelog/#020-21-january-2021","text":"This is major release that brings in a large number of improvements, with a huge number of commits. Some API breakage from the experimental 0.1.x series is likely in various edge-cases. Highlights include: Enriched formula parser to support quoting, and evaluation of formulas involving fields with invalid Python names. Added commonly used stateful transformations (identity, center, scale, bs) Improved the helpfulness of error messages reported by the formula parser. Added support for basic calculus on formulas (useful when taking the gradient of linear models). Made it easier to extend Formulaic with additional materializers. Many internal improvements to code quality and reliability, including 100% test coverage. Added benchmarks for Formulaic against R and patsy. Added documentation. Miscellaneous other bugfixes and cleanups.","title":"0.2.0 (21 January 2021)"},{"location":"changelog/#012-6-november-2019","text":"Performance improvements around the encoding of categorical features. Matthew Wardrop (1): Improve the performance of encoding operations.","title":"0.1.2 (6 November 2019)"},{"location":"changelog/#011-31-october-2019","text":"No code changes here, just a verification that GitHub CI integration was working. Matthew Wardrop (1): Update Github workflow triggers.","title":"0.1.1 (31 October 2019)"},{"location":"changelog/#010-31-october-2019","text":"This release added support for keeping track of encoding choices during model matrix generation, so that they can be reused on similarly structured data. It also added comprehensive unit testing and CI integration using GitHub actions. Matthew Wardrop (5): Add support for stateful transforms (including encoding). Fix tokenizing of nested Python function calls. Add support for nested transforms that return multiple columns, as well as passing through of materializer config through to transforms. Add comprehensive unit testing along with several small miscellaneous bug fixes and improvements. Add GitHub actions configuration.","title":"0.1.0 (31 October 2019)"},{"location":"changelog/#001-1-september-2019","text":"Initial open sourcing of formulaic . Matthew Wardrop (1): Initial (mostly) working implementation of Wilkinson formulas.","title":"0.0.1 (1 September 2019)"},{"location":"installation/","text":"The latest release of formulaic is always published to the Python Package Index (PyPI), from which it is available to download @ https://pypi.org/project/formulaic/ . If your Python environment is provisioned with pip , installing formulaic from the PyPI is as simple as running: $ pip install formulaic Otherwise, simply download the latest source package, extract it, and run from within the top-level \"formulaic\" source directory: $ python setup.py install Note If you have a non-standard setup, ensure that pip and/or python above are replaced with the executables corresponding to the environment for which you are interested in installing formulaic . This is done automatically if you are using a virtual environment. You are ready to use Formulaic. If you would like some guidance, please refer to the Basic Usage and Advanced Usage guides. Installing for development If you are interested in developing formulaic , you should clone the source code repository, and install in editable mode from there (allowing your changes to be instantly available to all new Python sessions). To clone the source code, run: $ git clone git@github.com:matthewwardrop/formulaic.git Note This requires you to have a GitHub account set up. If you do not have an account you can replace the SSH url above with https://github.com/matthewwardrop/formulaic.git . Also, if you are planning to submit your work upstream, you may wish to fork the repository into your own namespace first, and clone from there. To install in editable mode, run: $ pip install -e <path_to_cloned_formulaic_repo> You can then make any changes you like to the repo, and have them be reflected in your local Python sessions. Happy hacking, and I look forward to your contributions!","title":"Installation"},{"location":"installation/#installing-for-development","text":"If you are interested in developing formulaic , you should clone the source code repository, and install in editable mode from there (allowing your changes to be instantly available to all new Python sessions). To clone the source code, run: $ git clone git@github.com:matthewwardrop/formulaic.git Note This requires you to have a GitHub account set up. If you do not have an account you can replace the SSH url above with https://github.com/matthewwardrop/formulaic.git . Also, if you are planning to submit your work upstream, you may wish to fork the repository into your own namespace first, and clone from there. To install in editable mode, run: $ pip install -e <path_to_cloned_formulaic_repo> You can then make any changes you like to the repo, and have them be reflected in your local Python sessions. Happy hacking, and I look forward to your contributions!","title":"Installing for development"},{"location":"advanced/intro/","text":"Coming soon!","title":"Introduction"},{"location":"basic/formulas/","text":"This section introduces the basic notions and origins of formulas. If you are already familiar with formulas from another context, you might want to skip forward to the Quickstart . Origins Formulas were originally proposed by Wilkinson et al. 1 to aid in the description of ANOVA problems, but were popularised by the S language (and then R , as an implementation of S) in the context of linear regression. Since then they have been extended in R , and implemented in Python (by patsy ), in MATLAB , in Julia , and quite conceivably elsewhere. Each implementation has its own nuances and grammatical extensions, including Formulaic's which are described more completely in the Formula Grammar section of this manual. Why are they useful? Formulas are useful because they provide a concise and explicit specification for how data should be prepared for a model. Typically, the raw input data for a model is stored in a dataframe, but the actual implementations of various statistical methodologies (e.g. linear regression solvers) act on two-dimensional numerical matrices that go by several names depending on the prevailing nomenclature of your field, including \"model matrices\", \"design matrices\" and \"regressor matrices\" (within Formulaic, we refer to them as \"model matrices\"). A formula provides the necessary information required to automate much of the translation of a dataframe into a model matrix suitable for ingestion into a statistical model. Suppose, for example, that you have a dataframe with \\(N\\) rows and three numerical columns labelled: y , a and b . You would like to construct a linear regression model for y based on a , b and their interaction: \\[ y = \\alpha + \\beta_a a + \\beta_b b + \\beta_{ab} ab + \\varepsilon \\] with \\(\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)\\). Rather than manually constructing the required matrices to pass to the regression solver, you could specify a formula of form: y ~ a + b + a:b When furnished with this formula and the dataframe, Formulaic (or indeed any other formula implementation) would generate two model matrix objects: an \\( N \\times 1 \\) matrix \\(Y\\) for the response variable y , and an \\( N \\times 4 \\) matrix \\(X\\) for the input columns intercept , a , b , and a * b . You can then directly pass these matrices to your regression solver, which internally will solve for \\(\\beta\\) in: \\[ Y = X\\beta + \\varepsilon. \\] The true value of formulas becomes more apparent as model complexity increases, where they can be a huge time-saver. For example: ~ (f1 + f2 + f3) * (x1 + x2 + scale(x3)) tells the formula interpreter to consider 16 fields of input data, corresponding to an intercept (1), each of the f* fields (3), each of the x* fields (3), and the combination of each f with each x (9). It also instructs the materializer to ensure that the x3 column is rescaled during the model matrix materialization phase such that it has mean zero and standard error of 1. If any of these columns is categorical in nature, they would by default also be one-hot/dummy encoded. Depending on the formula interpreter (including Formulaic), extra steps would also be taken to ensure that the resulting model matrix is structurally full-rank. As an added bonus, some formula implementations (including Formulaic) can remember any choices made during the materialization process, and apply them to consistently to new data, making it possible to easily generate new data that conforms to the same structure as the training data. For example, the scale(...) transform in the example above makes use of the mean and variance of the column to be scaled. Any future data should, however, should not undergo scaling based on its own mean and variance, but rather on the mean and variance that was measured for the training data set (otherwise the new dataset will not be consistent with the expectations of the trained model which will be interpreting it). Limitations Formulas are a very flexible tool, and can be augmented with arbitrary user-defined transforms. However, some transformations required by certain models may be more elegantly defined via a pre-formula dataframe operation or post-formula model matrix operation. Another consideration is that the default encoding and materialization choices for data are aligned with linear regression. If you are using a tree model, for example, you may not be interested in dummy encoding of \"categorical\" features, and this type of transform would have to be explicitly noted in the formula. Nevertheless, even in these cases, formulas are an excellent tool, and can often be used to greatly simplify data preparation workflows. Where to from here? To get a feel for how you can use formulaic to transform your dataframes into model matrices, please review the Quickstart . To learn about the full set of features supported by the formula language as implemented by Formulaic, please review the Formula Grammar . For more advanced use-cases, such as overriding or customising the implementations of formula parsing, please refer to the Advanced Usage section. Wilkinson, G. N., and C. E. Rogers. Symbolic description of factorial models for analysis of variance. J. Royal Statistics Society 22, pp. 392\u2013399, 1973. \u21a9","title":"What are formulas?"},{"location":"basic/formulas/#origins","text":"Formulas were originally proposed by Wilkinson et al. 1 to aid in the description of ANOVA problems, but were popularised by the S language (and then R , as an implementation of S) in the context of linear regression. Since then they have been extended in R , and implemented in Python (by patsy ), in MATLAB , in Julia , and quite conceivably elsewhere. Each implementation has its own nuances and grammatical extensions, including Formulaic's which are described more completely in the Formula Grammar section of this manual.","title":"Origins"},{"location":"basic/formulas/#why-are-they-useful","text":"Formulas are useful because they provide a concise and explicit specification for how data should be prepared for a model. Typically, the raw input data for a model is stored in a dataframe, but the actual implementations of various statistical methodologies (e.g. linear regression solvers) act on two-dimensional numerical matrices that go by several names depending on the prevailing nomenclature of your field, including \"model matrices\", \"design matrices\" and \"regressor matrices\" (within Formulaic, we refer to them as \"model matrices\"). A formula provides the necessary information required to automate much of the translation of a dataframe into a model matrix suitable for ingestion into a statistical model. Suppose, for example, that you have a dataframe with \\(N\\) rows and three numerical columns labelled: y , a and b . You would like to construct a linear regression model for y based on a , b and their interaction: \\[ y = \\alpha + \\beta_a a + \\beta_b b + \\beta_{ab} ab + \\varepsilon \\] with \\(\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)\\). Rather than manually constructing the required matrices to pass to the regression solver, you could specify a formula of form: y ~ a + b + a:b When furnished with this formula and the dataframe, Formulaic (or indeed any other formula implementation) would generate two model matrix objects: an \\( N \\times 1 \\) matrix \\(Y\\) for the response variable y , and an \\( N \\times 4 \\) matrix \\(X\\) for the input columns intercept , a , b , and a * b . You can then directly pass these matrices to your regression solver, which internally will solve for \\(\\beta\\) in: \\[ Y = X\\beta + \\varepsilon. \\] The true value of formulas becomes more apparent as model complexity increases, where they can be a huge time-saver. For example: ~ (f1 + f2 + f3) * (x1 + x2 + scale(x3)) tells the formula interpreter to consider 16 fields of input data, corresponding to an intercept (1), each of the f* fields (3), each of the x* fields (3), and the combination of each f with each x (9). It also instructs the materializer to ensure that the x3 column is rescaled during the model matrix materialization phase such that it has mean zero and standard error of 1. If any of these columns is categorical in nature, they would by default also be one-hot/dummy encoded. Depending on the formula interpreter (including Formulaic), extra steps would also be taken to ensure that the resulting model matrix is structurally full-rank. As an added bonus, some formula implementations (including Formulaic) can remember any choices made during the materialization process, and apply them to consistently to new data, making it possible to easily generate new data that conforms to the same structure as the training data. For example, the scale(...) transform in the example above makes use of the mean and variance of the column to be scaled. Any future data should, however, should not undergo scaling based on its own mean and variance, but rather on the mean and variance that was measured for the training data set (otherwise the new dataset will not be consistent with the expectations of the trained model which will be interpreting it).","title":"Why are they useful?"},{"location":"basic/formulas/#limitations","text":"Formulas are a very flexible tool, and can be augmented with arbitrary user-defined transforms. However, some transformations required by certain models may be more elegantly defined via a pre-formula dataframe operation or post-formula model matrix operation. Another consideration is that the default encoding and materialization choices for data are aligned with linear regression. If you are using a tree model, for example, you may not be interested in dummy encoding of \"categorical\" features, and this type of transform would have to be explicitly noted in the formula. Nevertheless, even in these cases, formulas are an excellent tool, and can often be used to greatly simplify data preparation workflows.","title":"Limitations"},{"location":"basic/formulas/#where-to-from-here","text":"To get a feel for how you can use formulaic to transform your dataframes into model matrices, please review the Quickstart . To learn about the full set of features supported by the formula language as implemented by Formulaic, please review the Formula Grammar . For more advanced use-cases, such as overriding or customising the implementations of formula parsing, please refer to the Advanced Usage section. Wilkinson, G. N., and C. E. Rogers. Symbolic description of factorial models for analysis of variance. J. Royal Statistics Society 22, pp. 392\u2013399, 1973. \u21a9","title":"Where to from here?"},{"location":"basic/grammar/","text":"This section of the documentation describes the formula grammar used by Formulaic. It is almost identical that used by patsy and R, and so most formulas should work without modification. However, there are some differences, which are called out below. Operators In this section, we introduce a complete list of the grammatical operators that you can use by default in your formulas. They are listed such that each section (demarcated by \"-----\") has higher precedence then the block that follows. When you write a formula involving several operators of different precedence, those with higher precedence will be resolved first. \"Arity\" is the number of arguments the operator takes. Within operators of the same precedence, all binary operators are evaluated from left to right (they are left-associative). To highlight differences in grammar betweeh formulaic, patsy and R, we highlight any differences below. If there is a checkmark the Formulaic, Patsy and R columns, then the grammar is consistent across all three, unless otherwise indicated. Operator Arity Description Formulaic Patsy R \"...\" 1 1 String literal. \u2713 \u2713 \ud83d\uddd9 [0-9]+\\.[0-9]+ 1 1 Numerical literal. \u2713 \ud83d\uddd9 \ud83d\uddd9 `...` 1 1 Quotes fieldnames within the incoming dataframe, allowing the use of special characters, e.g. `my|special$column!` \u2713 \ud83d\uddd9 \u2713 {...} 1 1 Quotes python operations, as a more convenient way to do Python operations than I(...) , e.g. {`my|col`**2} \u2713 \ud83d\uddd9 \ud83d\uddd9 <function>(...) 1 1 Python transform on column, e.g. my_func(x) which is equivalent to {my_func(x)} \u2713 2 \u2713 \ud83d\uddd9 ----- (...) 1 Groups operations, overriding normal precedence rules. All operations with the parentheses are performed before the result of these operations is permitted to be operated upon by its peers. \u2713 \u2713 \u2713 ----- ** 2 Includes all n-th order interactions of the terms in the left operand, where n is the (integral) value of the right operand, e.g. (a+b+c)**2 is equivalent to `a + b + c + a:b + a:c + b:c \u2713 \u2713 \u2713 ^ 2 Alias for ** . \ud83d\uddd9 \ud83d\uddd9 3 \u2713 ----- : 2 Adds a new term that corresponds to the interaction of its operands (i.e. their elementwise product). \u2713 \u2713 \u2713 ----- * 2 Includes terms for each of the additive and interactive effects of the left and right operands, e.g. a * b is equivalent to a + b + a:b . \u2713 \u2713 \u2713 / 2 Adds terms describing nested effects. It expands to the addition of a new term for the left operand and the interaction of all left operand terms with the right operand, i.e a / b is equivalent to a + a:b , (a + b) / c is equivalent to a + b + a:b:c , and a/(b+c) is equivalent to a + a:b + a:c . 4 \u2713 \u2713 \u2713 %in% 2 Alias for / . \ud83d\uddd9 \ud83d\uddd9 \u2713 ----- + 2 Adds a new term to the set of features. \u2713 \u2713 \u2713 - 2 Removes a term from the set of features (if present). \u2713 \u2713 \u2713 + 1 Returns the current term unmodified (not very useful). \u2713 \u2713 \u2713 - 1 Negates a term (only implemented for 0, in which case it is replaced with 1 ). \u2713 \u2713 \u2713 ----- ~ 1,2 Separates the target features from the input features. If absent, it is assumed that we are considering only the the input features. Unless otherwise indicated, it is assumed that the input features implicitly include an intercept. \u2713 5 \u2713 \u2713 Transforms Formulaic supports arbitrary transforms, any of which can also preserve state so that new data can undergo the same transformation as that used during modelling. The currently implemented transforms are shown below. Commonly used transforms that have not been implemented by formualaic are explicitly noted also. Transform Description Formulaic Patsy R I(...) Identity transform, allowing arbitrary Python/R operations, e.g. I(x+y) . Note that in formulaic , it is more idiomatic to use {x+y} . \u2713 \u2713 \u2713 C(...) Categorically encode a column, e.g. C(x) partial 6 \u2713 \u2713 center(...) Shift column data so mean is zero. \u2713 \u2713 \ud83d\uddd9 scale(...) Shift column so mean is zero and variance is 1. \u2713 \u2713 7 \u2713 standardize(...) Alias of scale . \ud83d\uddd9 \u2713 \ud83d\uddd9 bs(...) Generates a B-Spline basis, allowing non-linear fits. \u2713 \u2713 \u2713 cr(...) Generates a natural cubic spline basis, allowing non-linear fits. \ud83d\uddd9 \u2713 \u2713 cc(...) Generates a cyclic cubic spline basis, allowing non-linear fits. \ud83d\uddd9 \u2713 \u2713 te(...) Generates a tensor product smooth. \ud83d\uddd9 \u2713 \u2713 ... Others? Contributions welcome! ? ? ? Note Formulaic does not (yet) support including extra terms in the formula that will not result in additions to the dataframe, for example model annotations like R's offset(...) . Behaviours and Conventions Beyond the formula operator grammar itself there are some differing behaviours and conventions of which you should be aware. Formulaic follows Patsy and then enhanced Formula R package in that both sides of the ~ operator are treated considered to be using the formula grammar, with the only difference being that the right hand side attracts an intercept by default. In vanilla R, the left hand side is treated as R code (and so x + y ~ z would result in a single column on the left-hand-side). You can recover vanilla R's behaviour by nesting the operations in a Python operator block (as described in the operator table): {y1 + y2} ~ a + b . Formula terms in Formulaic are always sorted first by the order of the interaction, and then alphabetically. In R and patsy, this second ordering is done in the order that columns were introduced to the formula (patsy additionally sorts by which fields are involved in the interactions). As a result formulas generated by formulaic with the same set of fields will always generate the same model matrix. Formulaic follows patsy's more rigourous handling of whether or not to include an intercept term. In R, b-1 and (b-1) both do not have an intercept, whereas in Formulaic and Patsy the parentheses are resolved first, and so the first does not have an intercept and the second does (because and implicit '1 +' is added prepended to the right hand side of the formula). Formulaic borrows a clever algorithm introduced by Patsy to carefully choose where to reduce the rank of the model matrix in order to ensure that the matrix is structurally full rank. This avoids producing over-specified model matrices in contexts that R would (since it only considers local full-rank structure, rather than global structure). You can read more about this in Patsy's documentation . This \"operator\" is actually part of the tokenisation process. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Formulaic additionally supports quoted fields with special characters, e.g. my_func(`my|special+column`) . \u21a9 The caret operator is not supported, but will not cause an error. It is ignored by the patsy formula parser, and treated as XOR Python operation on column. \u21a9 This somewhat confusing operator is useful when you want to include hierachical features in your data, and where certain interaction terms do not make sense (particularly in ANOVA contexts). For example, if a represents countries, and b represents cities, then the full product of terms from a * b === a + b + a:b does not make sense, because any value of b is guaranteed to coincide with a value in a , and does not independently add value. Thus, the operation a / b === a + a:b results in more sensible dataset. As a result, the / operator is right-distributive, since if b and c were both nested in a , you would want a/(b+c) === a + a:b + a:c . Likewise, the operator is not left-distributive, since if c is nested under both a and b separately, then you want (a + b)/c === a + b + a:b:c . Lastly, if c is nested in b , and b is nested in a , then you would want a/b/c === a + a:(b/c) === a + a:b + a:b:c . \u21a9 Formulaic additionally supports more than one ~ which splits the features into as many groups as you like. \u21a9 Formulaic only supports one-hot encoding, and does not yet support arbitrary contrast matrices or specification which field to leave out in reduced rank, etc. \u21a9 Patsy uses the rescale keyword rather than scale , but provides the same functionality. \u21a9","title":"Formula Grammar"},{"location":"basic/grammar/#operators","text":"In this section, we introduce a complete list of the grammatical operators that you can use by default in your formulas. They are listed such that each section (demarcated by \"-----\") has higher precedence then the block that follows. When you write a formula involving several operators of different precedence, those with higher precedence will be resolved first. \"Arity\" is the number of arguments the operator takes. Within operators of the same precedence, all binary operators are evaluated from left to right (they are left-associative). To highlight differences in grammar betweeh formulaic, patsy and R, we highlight any differences below. If there is a checkmark the Formulaic, Patsy and R columns, then the grammar is consistent across all three, unless otherwise indicated. Operator Arity Description Formulaic Patsy R \"...\" 1 1 String literal. \u2713 \u2713 \ud83d\uddd9 [0-9]+\\.[0-9]+ 1 1 Numerical literal. \u2713 \ud83d\uddd9 \ud83d\uddd9 `...` 1 1 Quotes fieldnames within the incoming dataframe, allowing the use of special characters, e.g. `my|special$column!` \u2713 \ud83d\uddd9 \u2713 {...} 1 1 Quotes python operations, as a more convenient way to do Python operations than I(...) , e.g. {`my|col`**2} \u2713 \ud83d\uddd9 \ud83d\uddd9 <function>(...) 1 1 Python transform on column, e.g. my_func(x) which is equivalent to {my_func(x)} \u2713 2 \u2713 \ud83d\uddd9 ----- (...) 1 Groups operations, overriding normal precedence rules. All operations with the parentheses are performed before the result of these operations is permitted to be operated upon by its peers. \u2713 \u2713 \u2713 ----- ** 2 Includes all n-th order interactions of the terms in the left operand, where n is the (integral) value of the right operand, e.g. (a+b+c)**2 is equivalent to `a + b + c + a:b + a:c + b:c \u2713 \u2713 \u2713 ^ 2 Alias for ** . \ud83d\uddd9 \ud83d\uddd9 3 \u2713 ----- : 2 Adds a new term that corresponds to the interaction of its operands (i.e. their elementwise product). \u2713 \u2713 \u2713 ----- * 2 Includes terms for each of the additive and interactive effects of the left and right operands, e.g. a * b is equivalent to a + b + a:b . \u2713 \u2713 \u2713 / 2 Adds terms describing nested effects. It expands to the addition of a new term for the left operand and the interaction of all left operand terms with the right operand, i.e a / b is equivalent to a + a:b , (a + b) / c is equivalent to a + b + a:b:c , and a/(b+c) is equivalent to a + a:b + a:c . 4 \u2713 \u2713 \u2713 %in% 2 Alias for / . \ud83d\uddd9 \ud83d\uddd9 \u2713 ----- + 2 Adds a new term to the set of features. \u2713 \u2713 \u2713 - 2 Removes a term from the set of features (if present). \u2713 \u2713 \u2713 + 1 Returns the current term unmodified (not very useful). \u2713 \u2713 \u2713 - 1 Negates a term (only implemented for 0, in which case it is replaced with 1 ). \u2713 \u2713 \u2713 ----- ~ 1,2 Separates the target features from the input features. If absent, it is assumed that we are considering only the the input features. Unless otherwise indicated, it is assumed that the input features implicitly include an intercept. \u2713 5 \u2713 \u2713","title":"Operators"},{"location":"basic/grammar/#transforms","text":"Formulaic supports arbitrary transforms, any of which can also preserve state so that new data can undergo the same transformation as that used during modelling. The currently implemented transforms are shown below. Commonly used transforms that have not been implemented by formualaic are explicitly noted also. Transform Description Formulaic Patsy R I(...) Identity transform, allowing arbitrary Python/R operations, e.g. I(x+y) . Note that in formulaic , it is more idiomatic to use {x+y} . \u2713 \u2713 \u2713 C(...) Categorically encode a column, e.g. C(x) partial 6 \u2713 \u2713 center(...) Shift column data so mean is zero. \u2713 \u2713 \ud83d\uddd9 scale(...) Shift column so mean is zero and variance is 1. \u2713 \u2713 7 \u2713 standardize(...) Alias of scale . \ud83d\uddd9 \u2713 \ud83d\uddd9 bs(...) Generates a B-Spline basis, allowing non-linear fits. \u2713 \u2713 \u2713 cr(...) Generates a natural cubic spline basis, allowing non-linear fits. \ud83d\uddd9 \u2713 \u2713 cc(...) Generates a cyclic cubic spline basis, allowing non-linear fits. \ud83d\uddd9 \u2713 \u2713 te(...) Generates a tensor product smooth. \ud83d\uddd9 \u2713 \u2713 ... Others? Contributions welcome! ? ? ? Note Formulaic does not (yet) support including extra terms in the formula that will not result in additions to the dataframe, for example model annotations like R's offset(...) .","title":"Transforms"},{"location":"basic/grammar/#behaviours-and-conventions","text":"Beyond the formula operator grammar itself there are some differing behaviours and conventions of which you should be aware. Formulaic follows Patsy and then enhanced Formula R package in that both sides of the ~ operator are treated considered to be using the formula grammar, with the only difference being that the right hand side attracts an intercept by default. In vanilla R, the left hand side is treated as R code (and so x + y ~ z would result in a single column on the left-hand-side). You can recover vanilla R's behaviour by nesting the operations in a Python operator block (as described in the operator table): {y1 + y2} ~ a + b . Formula terms in Formulaic are always sorted first by the order of the interaction, and then alphabetically. In R and patsy, this second ordering is done in the order that columns were introduced to the formula (patsy additionally sorts by which fields are involved in the interactions). As a result formulas generated by formulaic with the same set of fields will always generate the same model matrix. Formulaic follows patsy's more rigourous handling of whether or not to include an intercept term. In R, b-1 and (b-1) both do not have an intercept, whereas in Formulaic and Patsy the parentheses are resolved first, and so the first does not have an intercept and the second does (because and implicit '1 +' is added prepended to the right hand side of the formula). Formulaic borrows a clever algorithm introduced by Patsy to carefully choose where to reduce the rank of the model matrix in order to ensure that the matrix is structurally full rank. This avoids producing over-specified model matrices in contexts that R would (since it only considers local full-rank structure, rather than global structure). You can read more about this in Patsy's documentation . This \"operator\" is actually part of the tokenisation process. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Formulaic additionally supports quoted fields with special characters, e.g. my_func(`my|special+column`) . \u21a9 The caret operator is not supported, but will not cause an error. It is ignored by the patsy formula parser, and treated as XOR Python operation on column. \u21a9 This somewhat confusing operator is useful when you want to include hierachical features in your data, and where certain interaction terms do not make sense (particularly in ANOVA contexts). For example, if a represents countries, and b represents cities, then the full product of terms from a * b === a + b + a:b does not make sense, because any value of b is guaranteed to coincide with a value in a , and does not independently add value. Thus, the operation a / b === a + a:b results in more sensible dataset. As a result, the / operator is right-distributive, since if b and c were both nested in a , you would want a/(b+c) === a + a:b + a:c . Likewise, the operator is not left-distributive, since if c is nested under both a and b separately, then you want (a + b)/c === a + b + a:b:c . Lastly, if c is nested in b , and b is nested in a , then you would want a/b/c === a + a:(b/c) === a + a:b + a:b:c . \u21a9 Formulaic additionally supports more than one ~ which splits the features into as many groups as you like. \u21a9 Formulaic only supports one-hot encoding, and does not yet support arbitrary contrast matrices or specification which field to leave out in reduced rank, etc. \u21a9 Patsy uses the rescale keyword rather than scale , but provides the same functionality. \u21a9","title":"Behaviours and Conventions"},{"location":"basic/intro/","text":"In this portion of Formulaic's documentation, we introduce the high-level concepts behind formulas, where they are useful, and how to use the implementation of formulas provided by formulaic . If you are unfamiliar with formulas, a brief introduction is provided in the What are formulas? section. If you are already familiar, you can skip forward to the Quickstart and Formula Grammar sections. For a more detailed description of how Formulaic parses and materializes formulas, as well as how to augment and/or control this behavior, please refer to the Advanced Usage sections.","title":"Introduction"},{"location":"basic/quickstart/","text":"This document provides high-level documentation on how to get started using Formulaic. For deeper documentation about the internals, please refer to the Advanced Usage documentation. Building Model Matrices In formulaic , the simplest way to build your model matrices is to use the high-level model_matrix function: import pandas from formulaic import model_matrix df = pandas . DataFrame ({ 'y' : [ 0 , 1 , 2 ], 'a' : [ 'A' , 'B' , 'C' ], 'b' : [ 0.3 , 0.1 , 0.2 ], }) y , X = model_matrix ( \"y ~ a + b + a:b\" , df ) # This is short-hand for: # y, X = formulaic.Formula('y ~ a + b + a:b').get_model_matrix(df) # This lower-level API discussed in the Advanced Usage documentation. y = y 0 0 1 1 2 2 X = Intercept a[T.B] a[T.C] b a[T.B]:b a[T.C]:b 0 1.0 0 0 0.3 0.0 0.0 1 1.0 1 0 0.1 0.1 0.0 2 1.0 0 1 0.2 0.0 0.2 You will notice that the categorical values for a have been one-hot (aka dummy) encoded, and to ensure structural full-rankness of X 1 , one level has been dropped from a . For more details about how this guarantees that the matrix is full-rank, please refer to the excellent patsy documentation . If you are not using the model matrices for regression, and don't care if the matrix is not full-rank, you can pass ensure_full_rank=False : X = model_matrix(\"a + b + a:b\", df, ensure_full_rank=False) X = Intercept a[T.A] a[T.B] a[T.C] b a[T.A]:b a[T.B]:b a[T.C]:b 0 1.0 1 0 0 0.3 0.3 0.0 0.0 1 1.0 0 1 0 0.1 0.0 0.1 0.0 2 1.0 0 0 1 0.2 0.0 0.0 0.2 Note that the dropped level in a has been restored. Sparse Model Matrices By default, the generated model matrices are dense. In some case, particularly in large datasets with many categorical features, dense model matrices become hugely memory inefficient (since most entries of the data will be zero). Formulaic allows you to directly generate sparse model matrices using: X = model_matrix(\"a + b + a:b\", df, output='sparse') In this example, X is a \\( 6 \\times 3 \\) scipy.sparse.csc_matrix instance. X must be full-rank in order for the regression algorithm to invert a matrix derived from X . \u21a9","title":"Quickstart"},{"location":"basic/quickstart/#building-model-matrices","text":"In formulaic , the simplest way to build your model matrices is to use the high-level model_matrix function: import pandas from formulaic import model_matrix df = pandas . DataFrame ({ 'y' : [ 0 , 1 , 2 ], 'a' : [ 'A' , 'B' , 'C' ], 'b' : [ 0.3 , 0.1 , 0.2 ], }) y , X = model_matrix ( \"y ~ a + b + a:b\" , df ) # This is short-hand for: # y, X = formulaic.Formula('y ~ a + b + a:b').get_model_matrix(df) # This lower-level API discussed in the Advanced Usage documentation. y = y 0 0 1 1 2 2 X = Intercept a[T.B] a[T.C] b a[T.B]:b a[T.C]:b 0 1.0 0 0 0.3 0.0 0.0 1 1.0 1 0 0.1 0.1 0.0 2 1.0 0 1 0.2 0.0 0.2 You will notice that the categorical values for a have been one-hot (aka dummy) encoded, and to ensure structural full-rankness of X 1 , one level has been dropped from a . For more details about how this guarantees that the matrix is full-rank, please refer to the excellent patsy documentation . If you are not using the model matrices for regression, and don't care if the matrix is not full-rank, you can pass ensure_full_rank=False : X = model_matrix(\"a + b + a:b\", df, ensure_full_rank=False) X = Intercept a[T.A] a[T.B] a[T.C] b a[T.A]:b a[T.B]:b a[T.C]:b 0 1.0 1 0 0 0.3 0.3 0.0 0.0 1 1.0 0 1 0 0.1 0.0 0.1 0.0 2 1.0 0 0 1 0.2 0.0 0.0 0.2 Note that the dropped level in a has been restored.","title":"Building Model Matrices"},{"location":"basic/quickstart/#sparse-model-matrices","text":"By default, the generated model matrices are dense. In some case, particularly in large datasets with many categorical features, dense model matrices become hugely memory inefficient (since most entries of the data will be zero). Formulaic allows you to directly generate sparse model matrices using: X = model_matrix(\"a + b + a:b\", df, output='sparse') In this example, X is a \\( 6 \\times 3 \\) scipy.sparse.csc_matrix instance. X must be full-rank in order for the regression algorithm to invert a matrix derived from X . \u21a9","title":"Sparse Model Matrices"},{"location":"reference/api/","text":"Coming soon.","title":"API"}]}